"""Tester class"""
import numpy as np
import pandas as pd
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import transforms
from tqdm import tqdm

from .. import nets
from ..datasets import Searchstims, VOCDetection
from ..utils.transforms import normalize

NUM_WORKERS = 4


class Tester:
    """class for measuring accuracy of CNNs on test set after training for visual search task"""
    def __init__(self,
                 net_name,
                 csv_file,
                 restore_path,
                 num_classes=2,
                 batch_size=64,
                 device='cuda',
                 num_workers=NUM_WORKERS,
                 data_parallel=False,
                 ):
        """create new Tester instance

        Parameters
        ----------
        net_name : str
            name of convolutional neural net architecture to train.
            One of {'alexnet', 'VGG16'}
        new_learn_rate_layers : list
            of str
        csv_file : str
            name of .csv file containing prepared data sets.
            Generated by searchnets.data.split function from a csv created by the searchstims library.
        restore_path : str
            path to directory where checkpoints and train models were saved
        num_classes : int
            number of classes. Default is 2 (target present, target absent).
        batch_size : int
            number of training samples per batch
        device : str
            One of {'cpu', 'cuda'}
        num_workers : int
            Number of workers used when loading data in parallel. Default is 4.
        data_parallel : bool
            if True, use torch.nn.dataparallel to train network on multiple GPUs. Default is False.
        """
        self.net_name = net_name
        if net_name == 'alexnet':
            model = nets.alexnet.build(pretrained=False, progress=False, num_classes=num_classes)
        elif net_name == 'VGG16':
            model = nets.vgg16.build(pretrained=False, progress=False, num_classes=num_classes)

        self.data_parallel = data_parallel
        if data_parallel:
            model = nn.DataParallel(model)

        self.restore_path = restore_path
        model_file = str(restore_path) + '-model.pt'
        model.load_state_dict(
            torch.load(model_file)
        )
        model.to(device)
        self.model = model
        self.device = device

        self.testset = Searchstims(csv_file=csv_file,
                                   split='test',
                                   transform=transforms.Compose(
                                            [transforms.ToTensor(), normalize]
                                        ))
        self.test_loader = DataLoader(self.testset, batch_size=batch_size,
                                      shuffle=False, num_workers=num_workers,
                                      pin_memory=True)

        self.csv_file = csv_file
        self.dataset_df = pd.read_csv(csv_file)

        self.batch_size = batch_size

    def test(self):
        """method to test trained model

        Returns
        -------
        acc : float
            accuracy on test set
        pred : numpy.ndarray
            predictions for test set
        """
        self.model.eval()

        total = int(np.ceil(len(self.testset) / self.batch_size))
        pbar = tqdm(self.test_loader)
        acc = []
        pred = []
        with torch.no_grad():
            for i, (x_batch, y_batch) in enumerate(pbar):
                pbar.set_description(f'batch {i} of {total}')
                x_batch, y_batch = x_batch.to(self.device), y_batch.to(self.device)
                output = self.model(x_batch)
                # below, _ because torch.max returns (values, indices)
                _, pred_batch = torch.max(output.data, 1)
                acc_batch = (pred_batch == y_batch).sum().item() / y_batch.size(0)
                acc.append(acc_batch)

                pred_batch = pred_batch.cpu().numpy()
                pred.append(pred_batch)

        acc = np.asarray(acc).mean()
        pred = np.concatenate(pred)

        return acc, pred
